---
title: "NeovimとLua"
emoji: "🌕"
type: "tech"
topics: ["lua", "neovim"]
published: true
---

luaでのoption設定が2021年7月時点の情報です。それ以外は、2021年2月上旬時点から更新していません。そのため、[Neovim v0.5.1以上](https://github.com/neovim/neovim/releases)に対応していません。
この記事の最新版を書くとしても、Zennには投稿しません。MarkdownではなくAsciidocで書くからです。

[`vim.lsp.diagnostic` を `vim.diagnostic` に移動する](https://github.com/neovim/neovim/pull/15585)など、HEADのBreaking Changesは[このissue](https://github.com/neovim/neovim/issues/14090)にまとまっています。

NeovimのLuaプラグインを作成する場合、[nvim\-lua\-plugin\-template](https://github.com/nvim-lua/nvim-lua-plugin-template)が役に立つはずです。lintとtestの設定をしているtemplateです。

---
:::message alert
* Neovimについて記載しています。Vimではありません。記載している内容はVimでは使用できません。topicにVimがないのもこれが理由です。
  NeovimとVimの違いやNeovimの概要を知りたい人は、次の資料を読んでみてください。
  * [公式ドキュメント](https://neovim.io/doc/user/vim_diff.html)
  * [Neovimがどういうプロジェクトなのかまとめ](https://qiita.com/lighttiger2505/items/440c32e40082dc310c1e)
    [SQL Language Server\(sqls\)](https://qiita.com/lighttiger2505/items/5782debc59ae163a4d81)を開発している[lighttiger2505](https://twitter.com/LightTiger2505)さんが書いています。
* Neovimは[v0.5](https://github.com/neovim/neovim/commit/a5ac2f45ff84a688a09479f357a9909d5b914294)以上を使用していることを前提としています。
  [組み込みLSP](https://neovim.io/doc/user/lsp.html)と[treesitter](https://neovim.io/doc/user/treesitter.html)はv0.5から追加された機能です。記載しているLuaプラグインの大半は、v0.5から追加された[Lua API](https://neovim.io/doc/user/lua.html)を利用しています。
* Lua APIは詳しく書いていません。詳しく知りたい人は次の資料を読んでみてください。
  * [公式ドキュメント](https://neovim.io/doc/user/lua.html)
  * [nvim-lua-guide](https://github.com/nanotee/nvim-lua-guide/blob/master/README.md)
    [日本語訳](https://github.com/willelz/nvim-lua-guide-ja/blob/master/README.ja.md)
:::

:::message
NeovimのHEADで[破壊的変更](https://github.com/neovim/neovim/issues/14090)があったり、新機能が実装されても、新しい記事は書きません。この記事を更新する方針でいます。破壊的変更の記載は変更から3か月以上経ったら削除する方針でいます。
:::

Luaで書かれているNeovimプラグインを沢山発見し、理由が気になり調べた結果をまとめたものです。次の3つを記載しています。

* NeovimとLuaの相性がいい理由
* Luaを利用したNeovimの設定
* Lua製のプラグインの紹介
  プラグインマネージャーやLSP,fuzzy finderなどがあります。

:::message
Vim scriptはVim9 scriptを含んでいません。Vim9 scriptのことを書く際はVim9 scriptと明記します。
:::

# NeovimとLuaの関係

[NeovimはLua 5.1を組み込んでおり](https://neovim.io/doc/user/lua.html)、Luaを実行できます。そのため、Neovimのコマンドモードで `lua print('Hello World')` を実行すれば、 `Hello world` とメッセージを表示します。

# NeovimとLuaが相性が良い理由

Neovimの有名なコントリビューターの[TJ](https://github.com/tjdevries)さんは[Vimconfのプレゼン](https://www.youtube.com/watch?v=IP3J56sKtn0&feature=youtu.be)で次の5つといっています。

* 簡単
  Luaの学習コストは低く、誰でもすぐ書けます。
* Luaのサイズが小さい
  バイナリサイズ（linux用）は200KB以下です。
* 移植性
  ISO Cで実装されているため、OS Kernel内でもLuaは実行できます。
* 埋め込みに適している。
  Vim scriptからLuaの関数を呼び出すことができます。その逆もできます。
* Vim scriptよりスピードが早い
  Vim scriptなら約5.5秒かかる処理をLua(LuaJIT)は約0.003秒で処理します。

# Lua単体の感想

* 配列とdict両方になるtableは慣れれば見やすい

```lua
{1, 2, 3}  -- 配列
{a = 1, b = 2, c = 3}  -- dict
{1, b = 2, 3}  -- 配列とdict
```

* エスケープシーケンスがいらない `[[]]` が便利

```lua
'a\\a'    -- a\a
[[a\\a]]  -- a\\a
```

* 配列のindexが1開始は慣れれば気にならない

JavaScriptのTypeScriptのように、[Luaのコードに変換するtranspilers](https://github.com/nanotee/nvim-lua-guide#transpilers)があり、次のようなものがあります。

* TypescriptをLuaに変換する[TypeScriptToLua](https://typescripttolua.github.io/)
* coffeescriptと構文が似ている[moonscript](https://moonscript.org)
  [nvim-moonmaker](https://github.com/svermeulen/nvim-moonmaker)があれば、moonscriptでNeovimのプラグイン開発ができます。
* lispと構文が似ている[Fennel](https://fennel-lang.org/)
* Luaに型を付けた[tl](https://github.com/teal-language/tl)
* 静的型付けの[Haxe](https://haxe.org/)

# Vim scriptとLuaの比較

## Luaの良い点

* 改行時の `\` がいらない

Vim script
```vim
echo({ 'a': 1,
     \ 'b': 2 })  " `\` を削除するとエラー
```

Lua
```lua
print({ a = 1,
        b = 2 })
```

* 変数や関数のスコープ周りが楽

Vim script
```vim
function s:hoo(num)
  let num = 1
  " 引数の `num` ではなく、関数内で宣言した `num` の値(1)が表示されます。
  " 引数の `num` を表示させたい場合は `echo a:num` と書きます。
  echo num
endfunction
```

Lua
```lua
function hoo(num)
 print(num)  -- 引数の `num` が表示されます。
end
```

* dict時のkeyが文字列の場合、 `''` で囲む必要がない

Vim script
```Vim
{ 'a' : 1, 2 : 2 }

" `#{}` を使えばいりません。
" ネストする場合は、そのdictも `#{}` にする必要があります。
#{a: 1, 2: 2, d: {'a': 1}}
```

Lua
```lua
-- 数値の場合は `[]` で囲む必要があります。
-- 数値より文字列のkeyを使う場面が多いので、こちらのほうが楽です。
{ a = 1, [2] = 2 }
```

* 関数を呼ぶときに `call` がいらない

Vim script
```vim
" `echo` は関数ではなくコマンドなので `call` はいりません。
call foo()
```

Lua
```lua
foo()
```

* 関数やif文などの終わりが `end` に統一されている

Vim script
```vim
function foo()
  ...
endfunction

if i == 0
  ...
endif

for i in [1,2,3]
  ...
endfor
```

Lua
```lua
function foo()
  ...
end

if i == 0 then
  ...
end

for i, val in pairs({'a','b','c'}) do
  ...
end
```

## Luaの気になる点

* ifの `then` やforの `done`
  snippetを使えば自動で挿入されるので悪い点とまでは感じません。

Lua
```lua
if i == 0 then
  ...
end

for i, val in pairs({'a','b','c'}) do
  ...
end
```

# LuaでのNeovim設定

Vim scriptよりLuaのほうが設定は楽に感じています。大きいのが次の2点です。

* オプション（e.g. `set number`)やキーマップ（e.g. `nnoremap <silent> <C-w>d :delete<CR>`)などのコマンドを関数で実行できる
キーマップなどで変数の値を利用するときに `execute` コマンドを使う必要がありません。

Lua
```lua
-- execute('nnoremap <silent> <leader>' .. l:key .. ' :' .. l:cmd .. '<CR>')
vim.api.nvim_set_keymap('n', '<leader>' .. key, ':' .. cmd .. '<CR>',
                        { noremap = true, silent = true })
```
* 変数のスコープが楽
   Vim scriptのように引数を参照するため `a:`  をつける必要はありません。`l` や `s`, `g` などを気にするのはVim scriptの変数を利用するときのみです。

## 学習コスト

Vim scriptを知っている人の場合、[slin](https://zenn.dev/slin)さんが書いている記事も含む、次の参考資料を読めば30分もあれば理解できる印象です。Luaを知らない場合でも、Luaの文法は簡単なので合わせて1時間もあれば大丈夫な感じです。

* [nanotee/nvim\-lua\-guide: A guide to using Lua in Neovim](https://github.com/nanotee/nvim-lua-guide)
* [NeovimのためのLua入門 Lua基礎編](https://zenn.dev/slin/articles/2020-10-19-neovim-lua1)
* [NeovimのためのLua入門 init\.lua編](https://zenn.dev/slin/articles/2020-11-03-neovim-lua2)

## 変数やオプションなどの操作

LuaでNeovimの次の要素の管理や操作ができます。

### Vim script変数

[vim.{g|b|w|t|v|env}.<variable_name>](https://neovim.io/doc/user/lua.html#lua-vim-variables)でVim script変数を管理できます。

```lua
-- let g:hoo = 1
vim.g.hoo = 1
-- unlet g:hoo
vim.g.hoo = nil
-- let b:hoo = 1
vim.b.hoo = 1

-- let g:filename#variablename = 0
-- `''` で囲まないとエラーになります。
vim.g['filename#variablename'] = 0
```
:::message alert
* `vim.{b|w|t}` では、バッファ/ウィンドウ/タブを指定できません。
```lua
-- エラーになります。
vim.b[1].hoo = 1
```
* tableの1つのキーだけを追加/更新/削除できません。
```lua
vim.g.hoo = {}
vim.g.hoo.key = 1
-- {} になります。 { key = 1 } にはなりません。
print(vim.inspect(vim.g.hoo))

-- 一時的な変数を使用すれば、回避できます。
vim.g.hoo = {}
local hoo = vim.g.hoo
hoo.key = 1
vim.g.hoo = hoo
-- { key = 1 } になります。
print(vim.inspect(vim.g.hoo))
```
:::

vim.api.nvim_\*\*\*\_{set|get|del}\_varでも、Vim script変数を管理できます。
`vim.{b|w|t}` と違い、バッファ/ウィンドウ/タブを指定できます。

* グローバル（`g:`): [nvim_set_var](https://neovim.io/doc/user/api.html#nvim_set_var\(\))
* バッファ（`b:`): [nvim_buf_set_var](https://neovim.io/doc/user/api.html#nvim_buf_set_var\(\))
* ウィンドウ（`w:`): [nvim_win_set_var](https://neovim.io/doc/user/api.html#nvim_win_set_var\(\))
* タブ（`t:`): [nvim_tabpage_set_var](https://neovim.io/doc/user/api.html#nvim_tabpage_set_var\(\))
* Vimの定義済（`v:`): [nvim_set_vvar](https://neovim.io/doc/user/api.html#nvim_set_vvar\(\))

### option


[vim.{o|go|bo|wo}.<option_name>](https://neovim.io/doc/user/lua.html#lua-vim-options)でoptionの値を変更・取得できます。

:::message alert
`go` が実装される前と後で `o` の動作が違います。`go` が実装される前までは `o` が `go` と同じ動作をしていました。
[人々が期待するような動作を `o` はしていなかったので、`o` の動作を現在のように修正しました。そして、前の `o` の動作をする `go` を追加しました。](https://github.com/neovim/neovim/pull/13479#issuecomment-835783564)
:::

```lua
-- set cmdheight=2
vim.o.cmdheight = 2
-- set cmdheight?
print(vim.o.cmdheight)

-- 切り替えオプションはbooleanを利用します。
-- set noruler
vim.o.ruler = false

-- 略名も使えます。
-- set slm=""
vim.o.slm = ""

-- optsには {cmdheight = 2, ...} のようなオプションと値のobjectが格納されています。
for opt, val in pairs(opts) do vim.o.[opt] = val end
```

`set`のようにグローバルとローカル両方変変更したい場合は `o` を使います。

```lua
-- set cmdheight=1
vim.o.winminheight = 1
```

`setglobal` のようにグローバルの値だけを変更する場合は `go`
`setlocal` のようにローカルの値だけを変更する場合は `bo` or `wo` を使います。
`:help '<option-name>'` で表示されるhelpに
`global` ならグローバル、`local to {window|buffer}` ならローカルオプションです。

```lua
-- setglobal laststatus=0
vim.go.laststatus = 0
-- setlocal nonumber
vim.wo.number = false
```

ローカル（`bo` or `wo`)の場合は、バッファとウィンドウの番号を指定できます。
0の場合は、カレントバッファ/ウィンドウを指定します。

```lua
vim.bo[0].tabstop = 2
```

`opt` も `o` と同じように `set` のように動作します。
オプションの値を返すとき、`o` と `opt` で値が違います。
`o`   の場合は文字列、数値、真偽値を返します。
`opt` の場合はoption objectを返します。

```lua
-- set showtabline=0
vim.opt.showtabline = 0

print(vim.o.colorcolumn)                       -- 80
print(vim.inspect(vim.opt.colorcolumn))        -- { _info = {  ... },  _name = "colorcolumn", _value = "80", <metatable> = <1>{ ... } }
print(vim.inspect(vim.opt.colorcolumn:get()))  -- { "80" }
```

`set+=` `set-=` `set^=` と同じ動作をするメソッドが `opt` にはあります。

```lua
-- set tabstop+=10
vim.opt.tabstop:append(10)
vim.o.tabstop = vim.opt.tabstop + 10
-- set tabstop-=10
vim.opt.tabstop:remove(10)
vim.o.tabstop = vim.opt.tabstop - 10
-- set backupdir^='~/.config/nvim'
vim.opt.backupdir:prepend('~/.config/nvim')
```

`opt` は `set` に対応しており、
`opt_global` は `setglobal`、`opt_local` は `setlocal` に対応しています。

```lua
-- setlocal foldlevel+=2
vim.opt_local.foldlevel:append(2)
lua vim.wo.foldlevel = vim.wo.foldlevel + 2
```

vim.api.nvim_\*\*\*\_{set|get}\_optionでも、optionの値を変更・取得できます。
ただ、`set` や `vim.o` のようにグローバル・ローカル両方の値を変更できません。

* `go`: [nvim_set_option](https://neovim.io/doc/user/api.html#nvim_set_option\(\))
* `bo`: [nvim_buf_set_option](https://neovim.io/doc/user/api.html#nvim_buf_set_option\(\))
* `wo`: [nvim_win_set_option](https://neovim.io/doc/user/api.html#nvim_win_set_option\(\))

### Keymap


[vim.api.nvim_set_keymap](https://neovim.io/doc/user/api.html#nvim_set_keymap\(\))と[vim.api.nvim_buf_set_keymap](https://neovim.io/doc/user/api.html#nvim_buf_set_keymap\(\))を使います。

```lua
-- nnoremap <silent> <C-w>d :bdelete<CR>
vim.api.nvim_set_keymap('n', '<C-w>d', ':bdelete<CR>',
                        { noremap = true, silent = true })

-- mapsには {l = 'Lint', ...} のようなkeyとコマンドのdictが格納されています。
for key, cmd in pairs(maps) do
  vim.api.nvim_set_keymap(
    'n',
    '<leader>' .. key
    ':ALE' .. cmd .. '<CR>',
    { noremap = true, silent = true }
  )
end
```

`vim.keymap.nnoremap { '<leader>h', function() print("Hello world") end }` のような書き方ができる[API](https://github.com/neovim/neovim/pull/13823)を開発中です。[astronauta.nvim](https://github.com/tjdevries/astronauta.nvim)をインストールすると、開発中のAPIを使用できます。

### 関数

[vim.fn.<func_name>](https://neovim.io/doc/user/lua.html#vim.fn)を使います。

```lua
-- call abs(1)
vim.fn.abs(1)

-- call filename#funcname(1)
vim.fn['filename#funcname'](1)
```

### Vim script実行

[vim.cmd](https://neovim.io/doc/user/lua.html#vim.cmd\(\))を使います。

```lua
-- echo 123
vim.cmd('echo 123')
```

---

次の設定のinterfaceは現在実装されていませんが、実装される予定はあります。
`vim.cmd` でVim scriptを書いても設定できます。

* [User commandの作成](https://github.com/neovim/neovim/pull/11613)
* [autocmdの定義](https://github.com/neovim/neovim/pull/12378)
* [Syntax/Highlightの定義](https://github.com/neovim/neovim/issues/9876)
  [colorbuddy\.nvim: Your color buddy for making cool neovim color schemes](https://github.com/tjdevries/colorbuddy.nvim)

## Luaファイルの読み込み

[Vim scriptで書かれた設定 `init.vim` の代わりに、luaで書かれた設定 `init.lua` を読ませることができます。](https://neovim.io/doc/user/starting.html#config) `init.lua` を置く場所は `init.vim` と同じです。両方は読み込めず、両方ある場合は `Conflicting configs: ...` のメッセージが表示されます。

### require

`require('file_path')` でluaファイルをモジュールとして読み込みます。Neovimの `runtimepath` ディレクトリ内の `lua` ディレクトリに格納されているLuaファイルを `require` で読み込めます。

例

init.vim

*  `lua require('plugins')`
    ` ~/.config/nvim/lua/plugins/init.lua` を読み込みます。
*  `lua require('plugins.completion')`
    ` ~/.config/nvim/lua/plugins/completion.lua` を読み込みます。
* `lua require('plugins/completion')`
    `.` or `/` どっちでもOKです。 `.` のほうがよく見ます。

:::details ディレクトリ構成

```shell
# `~/.config/nvim` は `runtimepath` に含まれるディレクトリです。
~/.config/nvim
> ls init.vim lua/plugins/
init.vim

lua/plugins/:
completion.lua               finder.lua  linter.lua    parser.lua
download_plugin_manager.lua  git.lua     lsp.lua       status_and_tab_line.lua
filer.lua                    init.lua    markdown.lua  template.lua
```
:::

#### `require` はモジュールをキャッシュします

`require` でロードしたモジュールを変更した後、変更したモジュールをもう1度 `require` しても、モジュールは更新されません。どのモジュールをロードしたか `require` が記憶しているからです。
`packer.loaded` グローバルテーブルを変更すれば、モジュールを更新できます。

```lua
package.loaded['module_name'] = nil
require('module_name')
```

モジュールを更新するプラグイン

* [lreload.nvim](https://github.com/notomo/lreload.nvim)
  Luaモジュールのhot-reloadingができます。
* [nvim-lua/plenary.nvim](https://github.com/nvim-lua/plenary.nvim)
  Luaライブラリで、モジュール更新をする[関数](https://github.com/nvim-lua/plenary.nvim/blob/master/lua/plenary/reload.lua)があります。

### 自動で読みこまれるLuaファイル

`runtimepath`内の特定のフォルダ内にあるluaファイルを自動的に読みこみます。
現在、[次のフォルダ内のluaファイルを読みこみます。](https://github.com/neovim/neovim/pull/14686)

* colors
* compiler
* ftplugin
* ftdetect
* indent
* plugin
* syntax

:::message
[最初に全ての `*.vim` ファイルを、次に `*.lua` ファイルを読みこみます。](https://neovim.io/doc/user/starting.html#load-plugins)
:::

# Luaと他言語のプラグインの違い

他言語よりLuaで実装したプラグインのほうが処理速度は速いです。LuaはNeovim内部で動くため、プラグインとNeovim間のRTT(Round-Trip Time)が他の言語より短いです。

Vim scriptやLua以外の言語は[RPC(MessagePack-RPC)を使用して、Neovimを動かせます。](https://neovim.io/doc/user/api.html#rpc)Luaと違いNeovim内部で完結しているわけではないため、LuaよりRTTが長くなります。

# Vim9 script

VimでもVim scriptを改良した[Vim9 Script](https://github.com/brammool/vim9)を開発中です。今までのVim scriptより書きやすく、速度も改善されています。[LuaJITが有効ではないLuaより処理速度が速いです。](https://zenn.dev/mattn/articles/9c670e5ec661becb4d88#%E3%81%AA%E3%82%89%E3%81%B0%E6%9C%AC%E6%B0%97%E3%82%92%E8%A6%8B%E3%81%9B%E3%81%A6%E8%B2%B0%E3%81%8A%E3%81%86)開発中なので処理速度は今より速くなる可能性があります。[Vim8.2のhelp file](https://vim-jp.org/vimdoc-ja/usr_46.html)に記載されている通り、開発中のVim9 scriptはVim8.2で試せます。

NeovimがVim9 Scriptに対応するかどうかは調べておらず、対応するという情報は見つけていません。ただ、Neovimのコントリビューターの[TJ](https://github.com/tjdevries)さんがLuaJITと[LPEG](http://www.inf.puc-rio.br/~roberto/lpeg/)を利用して[Vim9 scriptのparserを開発しているようです。](https://github.com/tjdevries/vim9jit)

# Lua製のプラグイン

紹介するプラグインの大半は、[開発中のv0.5のNeovim](https://github.com/neovim/neovim/releases/tag/nightly)であることが必須条件です。

:::message
nvim-lspconfigやnvim-treesitter, completion-nvimで問題が発生した場合は `checkhealth` を実行しましょう。問題を解決する情報を得られるかもしれません。他のプラグインでも有益な情報を得られるかもしれないので `checkhealth` を覚えおくと役に立ちます。
:::

## [Packer.nvim](https://github.com/wbthomason/packer.nvim)

emacsの[use-package](https://github.com/jwiegley/use-package)に触発されたplugin/package managerです。
[Packer.nvimの作者によるdein.vimとの比較](https://github.com/wbthomason/packer.nvim/issues/282#issuecomment-816036052)

特徴

* [Native Packages](https://vim-jp.org/vimdoc-ja/repeat.html#packages)を使ってプラグインを読み込む
  プラグインの読み込みは `packadd` を利用する `packages` なため、`Packer.nvim` を利用しないor削除してもプラグインは読み込まれます。
* Luaで設定を書ける
* プラグインの遅延読み込みができる
* プラグインの依存関係を設定できる
* Post-install/update hook対応
* Luarocks対応

:::message
Native Packagesのリンク先は日本語のvimのhelpにしています。これは `:help pacakges` で表示される内容がNeovimとVimで同じだからです。
:::

:::details 詳細

### [Native Packages](https://vim-jp.org/vimdoc-ja/repeat.html#packages)を使ってプラグインを読み込む

Packagesはプラグインを含むディレクトリで、プラグインの数は1つor複数どちらでも大丈夫です。Pacakgesになるディレクトリは `packpath` (`set packpath?` で表示）にある `pack` という名前のディレクトリです。

PacakgeはNeovim起動時にプラグインを `runtimepath` へ追加して、scriptを読み込むか選択できます。これはプラグインを置いたディレクトリで決まります。

| ディレクトリ | 起動時にプラグインを読み込むか |
| --------- | ------------------------------ |
| `start`   | O                              |
| `opt`     | X                              |

起動時に読み込まない `opt` ディレクトリ内のプラグインは `packadd <direcotry_name>` で読み込みます。次のls結果の `opt/` 内にある `packer.nvim` を読み込む場合 `packadd packer.nvim` を実行します。`packadd! <direcotry_name>` のように `!` をつけた場合は `runtimepath` へ追加されますが、プラグインのファイルやftdetect scriptsは読み込まれません。`runtimepath` に追加されるため、プラグインのautoload関数は使えます。この `packadd!` は `init.vim` や `.vimrc` に書くときに便利です。

```shell
# `~/.local/share/nvim/site` はpackpathに含まれます。
# packpathの `~/.local/share/nvim/site` にある `pack` ディレクトリ内の
# `packer` がpacakgesになります。
~/.local/share/nvim/site/pack/packer
> ls opt/ start/
# 起動時に読み込まないプラグイン
opt/:
ale                    neosnippet.vim           popup.nvim            vim-fugitive
auto-pairs             nnn.vim                  preview-markdown.vim  vim-quickrun
completion-buffers     nvim-treesitter          sonictemplate-vim     vim-surround
completion-nvim        nvim-treesitter-context  tcomment_vim
completion-treesitter  packer.nvim              telescope.nvim
neosnippet-snippets    plenary.nvim             undotree

# 起動時に読み込むプラグイン
start/:
indentLine  nvim-lsp  tokyonight-vim  vim-gitgutter  vimdoc-ja
```

`start` のプラグインを読み込む手順は次のとおりです。

1. `init.vim` を読み込む
1. `start` ディレクトリ内のプラグインを読み込む
1. `plugins` ディレクトリ内のファイルを読み込む

このため `pluigns` ディレクトリに `start` のプラグインに依存しているVim scriptを書いてもエラーは発生しません。

`Packer.nvim` の大きな役割は次の2つです。

* プラグイン管理
  * Install(`PackerInstall`)
  * Update(`PackerUpdate`)
  * 使用しないプラグインの削除（`PackerClean`)
* プラグインの設定をするVim scriptファイルの生成（`PackerCompile`)
  デフォルトで `~/.config/nvim/plugin/packer_compiled.vim` として出力します。 `~/.config/nvim/plugin` 内のVim scriptは起動時に読み込まれるので、起動時に生成した設定ファイルは読み込まれす。 起動時に読み込むプラグインは `plugin` ディレクトリ内のscirptを読み込む前に利用できますのでエラーは発生しません。
設定ファイルに書き込まれる内容は次のようなものがあります。
  * Neovim起動時に読み込む設定 (e.g. 変数やキーマップ）
    起動時に読み込むプラグインの場合Neovim起動時 = プラグイン読み込み時になりますが、遅延読み込みするプラグインの場合は違います。
  * プラグイン読み込み時の設定 (e.g. 変数やキーマップ）
  * 遅延読み込みするプラグインの読み込むトリガー
    * 特定keyを押す
    * 特定のfiletypeのバッファを開く
    * 特定のcommand or eventを実行

この2つの動作をするときに `packer.nvim` を読み込むよう作成者の[Wil Thomason](https://github.com/wbthomason)さんは[設定](https://github.com/wbthomason/dotfiles/blob/linux/neovim/.config/nvim/plugin/plugins.vim)しており、Neovim起動時に `packer.nvim` を読み込んでいません。

### Luaで設定を書ける

次のように利用するプラグインを設定していきます。

```lua
return require('packer').startup(function()
  -- `packer.nvim` を管理するプラグインに追加します。
  -- `opt` はプラグインの設定の1つです。値の意味は後述します。
  use { 'wbthomason/packer.nvim', opt = true }

  -- 1つの `use` で複数のプラグインを追加できます。
  use { 'tpope/vim-fugitive', 'airblade/vim-gitgutter' }
  use {
    {
      'nvim-lua/completion-nvim',
      event = 'InsertEnter *',
      config = function() vim.cmd('packadd completion-buffers') end
    },
    { 'steelsojka/completion-buffers', opt = true },
  }
end)
```

プラグインの設定の1つの `config` はプラグイン読み込み時に実行するコードを記載します。プラグイン読み込み時なので、起動時に読み込まない遅延読み込みのプラグインの場合はNeovim起動時に実行されません。遅延読み込みするプラグインでNeovim起動時に実行したいコードがある場合は `setup` を使います。

```lua
use {
  'tpope/vim-fugitive',
  config = function()
    local maps = {s = 'status', ... }
    for key, cmd in pairs(maps) do
      vim.api.nvim_set_keymap('n', '[git]' .. key, ':G' .. cmd .. '<CR>',
                              { noremap = true, silent = false })
    end
  end
}
```

Luaの `require` を使い、プラグインを複数のファイルに分けることができます。

```lua:lua/plugins/init.lua
return require('packer').startup(function()
  -- for _, path in pairs{ 'git', ... } do use(require('plugins.' .. path)) end
  -- でもOKです。
  vim.tbl_map(
    function(path) use(require('plugins.' .. path)) end,
    {
      'git', 'template', 'linter', 'status_and_tab_line', 'parser', 'finder',
      'lsp', 'filer', 'completion', 'markdown'
    }
  )
end)
```

```lua:lua/plugins/git.lua
return {
  {
    'tpope/vim-fugitive',
    -- 長いコード
  },
  {
    'airblade/vim-gitgutter'
  }
}
```

```shell
# `~/.config/nvim` はruntimepahtに含まれるディレクトリです
~/.config/nvim
> ls init.vim lua/plugins/
init.vim

lua/plugins/:
completion.lua               finder.lua  linter.lua    parser.lua
download_plugin_manager.lua  git.lua     lsp.lua       status_and_tab_line.lua
filer.lua                    init.lua    markdown.lua  template.lua
```

### プラグインの遅延読み込みができる

`use { 'wbthomason/packer.nvim', opt = true }` の `opt` は[プラグインの設定](https://github.com/wbthomason/packer.nvim#specifying-plugins)の1つです。`opt`が `true` ならプラグインを `opt` ディレクトリに配置して、起動時読み込まないようにします。読み込む場合は `packadd <plugin_name>` を使います。`opt` を記載しない場合の値は設定で変更でき、デフォルトでは `false` です。

`opt` 以外にも遅延読み込みプラグインに設定するオプションは次があります。設定するとプラグインは `opt` ディレクトリに配置され、起動時に読み込まれません。起動時に読み込むプラグインを遅延読み込みに変更する場合は `PackerUpdate` が必要です。

| key   | プラグインを読み込む瞬間    |
| ----- | --------------------------- |
| cmd   | 値のcommandを実行           |
| ft    | 値のfiletypeのバッファを開く|
| keys  | 値のkeyを押す               |
| event | 値のeventを実行             |
| cond  | 値のtestが通ったとき        |
| setup | なし                        |

```lua
use {
  'skanehira/preview-markdown.vim',

  -- プラグインを読み込むトリガーが2つある場合、
  -- 1つでも条件が成立したときに
  -- プラグインは読み込まれます。
  ft = 'markdown',
  cmd = 'PreviewMarkdown',
  setup = function()
    -- `<M-r>m` で `cmd` のコマンドを実行するので、
    -- `<M-r>m` を押せば、プラグインは読み込まれます。
    -- `setup` ではなく `config` にキーマップのコードを書いた場合、
    -- プラグイン読み込み時にキーマップが登録されるので、
    -- `<M-r>m` を押しても何も反応せず、プラグインも読み込まれません。
    vim.api.nvim_set_keymap('n', '<M-r>m', ':PreviewMarkdown<CR>',
                            { noremap = true, silent = true })
  end,
  config = function()
    vim.g.preview_markdown_parser      = "mdcat"
    vim.g.preview_markdown_vertical    = 1
    vim.g.preview_markdown_auto_update = 1
  end
}
```

### プラグインの依存関係を設定できる

`requires` keyを使い依存するプラグインを設定できます。

```lua
use {
  ...
  requires = { 'depend/plugin' },
},
```

依存されている（i.e. `depend/plugin`)のプラグインがない場合、デフォルトではインストールします。[インストールしないようにすることもできます。](https://github.com/wbthomason/packer.nvim#dependencies)
依存しているプラグインが利用されていない場合、 `requires` 内のプラグインは必要ないプラグインとなり `PackerClear` で削除されます。

```lua
-- PackerCleanすると両方のプラグインは削除されます。
use {
  'plugin/a',
  opt = true,
  -- プラグインを無効にして利用しないようにします。
  disable = true,
  requires = { 'plugin/a', opt = true },
}

-- 1つの `use` で複数のプラグインを設定している場合
-- `plugin/a` のみ削除されます。
use {
  { 'plugin/a', opt = true, disable = true },
  { 'plugin/b', opt = true },
},
```

### Post-install/update hook対応

`installer` や `updater`, `run` を使えばプラグインをinstall,update時に指定の処理を実行できます。

```lua
use {
  'iamcco/markdown-preview.nvim',
  -- Install,Update時に実行する処理
  run = 'cd app && yarn install'
}
```

`run` が文字列の場合、先頭の文字が `:` ならneovimのコマンドが実行され、`:` ではない場合shellコマンドとして実行されます。Shellの場合 `$SHELL -c 'cd <plugin dir> && <run>'` で実行します。

### Luarocks対応

* `rocks`: プラグインに依存しているrocksを設定します
* `use_rocks`: インストールするrocksを設定します

### 注意事項

#### `PackerCompile` を実行しないと設定は反映されません

`config` や `event` などの設定を変更しても `PackerCompile` を実行して `packer_compiled.vim` を更新しないと設定は反映されません。`use { ... }` を記載している設定ファイルではなく、 `PackerCompile` で出力している `packer_compiled.vim` を、Neovimが起動時に読み込んでいるからです。

`PackerCompile` を変更するたびに実行するのがめんどくさい場合は `autocmd BufWritePost plugins.lua PackerCompile` のような設定をしてください。

#### `config` や `setup` の値の関数にエラーがあっても `PackerCompile` 実行時に発生しません

設定内のLuaにエラーがある場合、 `PackerCompile` 実行時にエラーは発生します。 `config` に文字列を設定した場合もそうです。しかし `config` に関数を設定し、その関数内にエラーがある場合 `PackerCompile` 実行時ではなく、プラグインが読み込まれ関数を実行するときにエラーは発生します。`setup` や `cond` も同じです。

関数の場合なので `config = require('<存在しないプラグイン名>')` の場合は `PackerCompile` 実行時にエラーが発生します。`config = function() require('<存在しないプラグイン名>') end` の場合は発生せず、関数実行時に発生します。

`vim:config = function() require('<存在しないプラグイン名>') end` のときのエラー内容

```vim
" `packer_compiled.vim` は `PackerCompile` で生成するファイル
Error detected while processing ... /plugin/packer_compiled.vim:
line  297:
E5108: Error executing lua [string "..."]:0: module 'aaa' not found:
        no field package.preload['aaa']
        no file './aaa.lua'
	...
```

#### 遅延読み込みのON・OFFの変更は `PackerUpdate` する必要があります

`use { ..., opt = false }` の `opt` を `true` に変更して、起動時に読み込むのではなく遅延読み込みに変更する場合 `PackerCompile` を実行して `packer_compiled.vim` を更新し設定を変更するだけでは駄目です。`PackerUpdate` を実行する必要があります。
実行しないとプラグインが `start` ディレクトリに存在するため、Neovimが起動時に読み込んでしまい、遅延読み込みになりません。`PackerUpdate` を実行してプラグインのディレクトリを `start` から `opt` に移動すれば、起動時に読み込まれません。
遅延読み込みから起動時読み込むに変更するときも同じです。

この `PackerUpdate` 忘れによる `start` と `opt` ディレクトリの移動し忘れは `config` や `setup` などでエラーが発生する原因になります。

#### 起動時に読み込むプラグインの削除する場合は `PackerClean` をする必要があります

起動時に読み込むプラグインを削除したい場合、そのプラグインの `use` のコードを削除して `PackerCompile` して設定を変更するだけでは駄目です。 `start` ディレクトリにプラグインが残っているので起動時にNeovimはそのプラグインを読み込みます。 `PackerClean` を実行して `start` ディレクトリから削除する必要があります。`disable = true` も同じです。

`PackerUpdate` を実行しても削除はしません。`PackerSync` を実行すれば `PackerClean` をやったあとに `PackerUpdate` を実行してくれます。

#### `use` や `requires` のプラグインが複数の場合、tableで書かないとオプションは適用されません

次の設定で `completion-nvim` はインストールされますが `{}` で囲まれていないので `event` や `config` の設定は `PackerCompile` しても `packer_compiled.vim` に反映されません。そのため `completion-nvim` は遅延読み込みではなく、起動時に読み込まれます。
`{}` で囲まれてないから `PackerCompile` 時にエラーが発生することはありません。

```lua
use {
  -- `{}` に囲まれていないため
  -- `{ 'nvim-lua/completion-nvim', { ... }` と
  -- 同じ設定になります。
  'nvim-lua/completion-nvim',
  event = 'InsertEnter *',
  config = vim.cmd('packadd completion-buffers')
  { 'steelsojka/completion-buffers', opt = true },
}

-- `requires` の場合も同じなのでtableにする必要があります。
use {
  ...,
  requires = {{ 'plugin/a', opt = true }, { 'plugin/b', opt = true }}`
}
```

:::

## [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)

[v0.5](https://neovim.io/roadmap/)で実装される[組込みのLSP(Language Server Protocol)クライアント](https://neovim.io/doc/user/lsp.html)用の共通設定集です。

組み込みのLSPクライアントの設定が簡単になるだけで、これがないと組み込みのLSPクライアントが使えず、LSPの機能が使えないというわけではありません。[クライアントはneovim本体に組み込まれており、Luaで書かれています。](https://github.com/neovim/neovim/tree/a22fe09b90a52f451d9fd8d3372b8c390dd1dc1a/runtime/lua/vim/lsp)なぜNeovimにLSPクライアントが組み込まれたかはtjさんの[動画](https://www.reddit.com/r/neovim/comments/krghi3/why_neovim_lsp_client_by_tj/)が参考になります。

[vim\-lsp](https://github.com/prabirshrestha/vim-lsp)や[coc.nvim](https://github.com/neoclide/coc.nvim),[LanguageClient\-neovim](https://github.com/autozimu/LanguageClient-neovim)などの有名なLSPクライアントとNeovimの組み込みのLSPクライアントとの違いなどは次の記事を参考にしてみてください。

* [Vim で使える LSP クライアント各種を使った感想](https://qiita.com/hrsh7th@github/items/878e62f02d8c177baa42)
* [Why I still prefer LSC to Neovim LSP \+ completion\.nvim, even as Neovim user : neovim](https://www.reddit.com/r/neovim/comments/j915tl/why_i_still_prefer_lsc_to_neovim_lsp/)

### 利用方法

Luaのlanguage serverを利用するには次の手順でやります。

1. nvim-lspconfigをインストール
1. LuaのLSP serverの[sumneko_lua](https://github.com/sumneko/lua-language-server)をインストール
  両方ともbuild systemの[ninja](https://github.com/ninja-build/ninja)が必要です。
    * 手動
    sumneko_luaの[wiki](https://github.com/sumneko/lua-language-server/wiki/Build-and-Run-\(Standalone\))の手順でインストールします。
    CONFIG.mdの設定をそのまま使用したいので `git clone https://github.com/sumneko/lua-language-server` は `git clone https://github.com/sumneko/lua-language-server ~/.cache/nvim/lspconfig/sumneko_lua/lua-language-server` に変更します。
    * [nvim-lspinstall](https://github.com/anott03/nvim-lspinstall)を利用
    nvim-lspinstallをインストールし、 `LspInstall sumneko_lua` コマンドを実行します。
   `~/.local/share/nvim/lspinstall/lua-langauge-server` に配置されます。
1. `init.vim` or `init.lua` に[CONFIG.mdの設定](https://github.com/neovim/nvim-lspconfig/blob/master/CONFIG.md#sumneko_lua)を追加
   nvim-lspinstallの場合は `sumneko_root_path` を `vim.fn.stdpath('data') .. '/lspinstall/lua-langauge-server'` に変更してください。
1. Neovimを再起動
1. `set ft=lua` で編集中のバッファをluaに変更する
1. `sumneko_lua` が起動して、編集中のバッファに接続する
   診断機能が有効になっているのでsyntax errorがあると、syntax errorの診断メッセージがvirtual textで表示されます。
   `LspInfo` で起動しているLSPクライアントや編集中のバッファと接続しているLSPクライアントの情報がわかります。動かない場合は `checkhealth` を実行してみましょう。

定義ジャンプやsymbol参照などの方法は `help lsp-config` や[slin](https://qiita.com/slin)さんの[NeovimのBuiltin LSPを使ってみる](https://qiita.com/slin/items/2b43925065de3b9a6d3b)を参照してください。LSPで何ができるかは[北川亮](https://kitagry.github.io/blog/)さんの[vim\-lspでできること](https://qiita.com/kitagry/items/216c2cf0066ff046d200)も参考になります。vim-lspについて書いてますが、大体はNeovimの組み込みのLSPでもできるはずです。

### 注意事項

#### `LspIntall` と `LspInstallInfo` の廃止

[Remove all installers and install logic #498](https://github.com/neovim/nvim-lspconfig/pull/498)により廃止されました。Pull requestの作成者の[mjlbach](https://github.com/mjlbach)さんの[コメント](https://www.reddit.com/r/neovim/comments/kslzkh/how_to_use_and_contribute_to_neovims_builtin/)を読むと次の2点があるようです。

* LSP serverが古いせいで発生するbugを修正する仕組みがない
* LSP serverをインストールできるソース(npm, linux package manager, brew)が多種多様で、全てをサポートするのが大変

今後LSP serverをインストールする際は次の手段があります。

* [CONFIG\.md](https://github.com/neovim/nvim-lspconfig/blob/master/CONFIG.md)を読みながら手動でする
* [vim\-lsp\-settings](https://github.com/mattn/vim-lsp-settings)を使う
* [nvim\-lspinstall](https://github.com/anott03/nvim-lspinstall)を使う
  [CONFIG\.md](https://github.com/neovim/nvim-lspconfig/blob/master/CONFIG.md)の全てをまだインストールできません。将来的には全てできる予定です。
* [nvim\-lspupdate](https://github.com/alexaandru/nvim-lspupdate)を使う
  インストールとアップデート、両方できます。

### LSP関連の他のプラグイン

* [lspsaga.nvim](https://github.com/glepnir/lspsaga.nvim)
  定義や参照一覧、定義やdocument情報をfloating windowで表示できます。
* [nvim\-lsputils](https://github.com/RishabhRD/nvim-lsputils)
  使用できるcode actionsをfloating windowで表示したり、定義ジャンプやsymbol参照の一覧とそのpreviewをquickfixを使って表示できます。
* [nvim\-lspfuzzy](https://github.com/ojroques/nvim-lspfuzzy)
  FZFを利用して、定義ジャンプなどのLSP操作を行います。
* [nvim-lightbulb](https://github.com/kosayoda/nvim-lightbulb)
  現在の行で `textDocument/codeAction` ができるか表示します。
* [aerial\.nvim](https://github.com/stevearc/aerial.nvim)
  Symbolsを目次形式で表示し、選択したsymbolに移動します。
* [folding\-nvim](https://github.com/pierreglaser/folding-nvim)
  折りたたみにLSPを使います。
* [nvim\-lsp\-smag](https://github.com/weilbith/nvim-lsp-smag)
  NeovimにLSPをシームレスに統合できるようにして、タグファイルまたは `vim.lsp.client` を利用する処理全体を単純化します。 `tagfunc` オプションを利用して、tagの検索方法をカスタマイズできます。
* [lsp-status.nvim](https://github.com/nvim-lua/lsp-status.nvim)
  組み込みのLSPクライアントからstatuslineのcomponentを生成します。
* [onsails/lspkind-nvim](https://github.com/onsails/lspkind-nvim)
  VSCode-like iconsを追加します。
* [lsp_extensions.nvim](https://github.com/nvim-lua/lsp_extensions.nvim)

#### diagnostics

* [nvim-ale-diagnostic](https://github.com/nathunsmitty/nvim-ale-diagnostic)
  Neovim LSPのdiagnostics結果をaleで表示します。

### 言語特有のプラグイン

* [nvim\-lsp\-ts\-utils](https://github.com/jose-elias-alvarez/nvim-lsp-ts-utils)
  TypeScriptの開発を支援します。
  * [importの整理](https://devblogs.microsoft.com/typescript/announcing-typescript-2-8-2/#organize-imports)(`LspOrganize`)
    未使用importの削除&並べ替えを行ないます。
  * 現在行に利用可能なコードアクション（`vim.lsp.buf.code_action()`)を利用（`LspFixCurrent`)
    複数ある場合は1番最初のコードアクションを実行します。
  * ファイル名変更とimportの更新（`LspRenameFile`)
  * 足りないimportを追加（`LspImportAll`)

### 組み込みのLSPクライアントと[coc.nvim](https://github.com/neoclide/coc.nvim)の違い

nvim-lspconfigのコントリビューターの[mjlbach](https://github.com/mjlbach)さんの[コメント](https://www.reddit.com/r/neovim/comments/kslzkh/how_to_use_and_contribute_to_neovims_builtin/)を自分なりに解釈して、それをまとめた文です。

* 組み込みのLSPクライアントは拡張性が高く、neovimの設定を変更すれば多くの点を変更できる
  全てluaで書かれているため、簡単にカスタマイズできます。ハンドラベースで、動作を上書きするのも非常に簡単です。
* nvim-lspconfigはCocプラグインと同等の機能を提供しない
 エコシステムではなく、最低限のdefault機能を提供するのをnvim-lspconfigは目的としているからです。[nvim-jdtls](https://github.com/mfussenegger/nvim-jdtls)のようなCocプラグインと同等の機能を持ったプラグインは今後増えていく可能性があります。

#### 参考にしたコメント

* [Why should I use the in built LSP over coc\.vim? : neovim](https://www.reddit.com/r/neovim/comments/l6y9fp/why_should_i_use_the_in_built_lsp_over_cocvim/gl3uufn/?utm_source=reddit&utm_medium=web2x&context=3)
* [How to use \(and contribute\) to neovim's built\-in language server client and nvim\-lspconfig : neovim](https://www.reddit.com/r/neovim/comments/kslzkh/how_to_use_and_contribute_to_neovims_builtin/)


## [nvim-treesitter.nvim](https://github.com/nvim-treesitter/nvim-treesitter)

Tree-sitterの設定をするプラグインです。Neovimに存在する[tree-sitterのlibrary](https://neovim.io/doc/user/treesitter.html)を利用しています。

### [Tree-sitter](https://tree-sitter.github.io/tree-sitter/)とは

:::details 詳細

#### 役割

* Parserの作成
* 漸進的分析（Incremental Parsing) library

#### 特徴

* Concrete Syntax Treeを構築します
  [`()` などの言語の意味を理解するのに必要ないものを省略して、意味のある部分だけを抽出したAbstract Syntax Treeと違い、省略せず全てのコードの情報を持っています。](https://stackoverflow.com/questions/1888854/what-is-the-difference-between-an-abstract-syntax-tree-and-a-concrete-syntax-tre)全ての情報を持っているためsyntaxに一致するコードの開始と終了位置がわかります。それによりsyntaxが別のsyntax内に含まれているのがわかり、プログラミング言語の文法としてそのsyntaxがどのような意味を持つか正確に把握できます。(この理解であっている自信がありません。間違っていたら教えていただくとありがたいです）
* 変更部分のみを分析してsyntax treeを更新します
  大きなsyntax tree(e.g. 長いコードや複雑なコード）であっても、変更部分のみを分析更新するため、処理速度が速いです。

[Tree-sitterの公式サイトでtree-sitterを試せて、syntax treeの動きを確認できます。](https://tree-sitter.github.io/tree-sitter/playground)

#### 目標

* どんなプログラミング言語でもparsesする
* Key操作全てを解析できる速さ
* Syntax errorがあっても有効な情報を提供する
* 任意のアプリケーションへ組み込めるようにする
  tree-sitterは純粋なC言語で書かれているため依存しているものはありません。

#### エディタのどの機能に役立つか

実際に動かしている動画がリンク先にあります。

* [Syntax Highlighting](https://youtu.be/Jes3bD6P0To?t=373)
  今まで色がついてなかった文字に色がつきます。
* [Code Folding(折りたたみ表示)](https://youtu.be/Jes3bD6P0To?t=748)
  Indentとsyntaxが一致しない場合でも関数などが折りたたみ表示されます。
* [Extend Selection(範囲選択拡大)](https://youtu.be/Jes3bD6P0To?t=950)
  1つ上のスコープなどに選択範囲を拡大などができます。
* [Refactoring with Extend Selection](https://youtu.be/Jes3bD6P0To?t=1005)
  選択範囲のコードを変更できます。選択範囲は複数かつ、離れ離れでもOKです。

#### [Language serversとの比較](https://youtu.be/Jes3bD6P0To?t=258)

* ParseがLanguage serverより速い
* 依存関係がない
  Language serverはそれぞれに依存関係がある

:::

### 機能

* [highlight](https://github.com/nvim-treesitter/nvim-treesitter/wiki/Gallery)
  今まで色がついてない部分に色がつきます。
* Incemental selection
  textobject単位の選択の拡大ができます。
* Indent
  Indentを整える（`={motion}`)処理をTreesitterのparseをもとにおこないます。

#### 追加モジュールとプラグイン

モジュール

* [textobject](https://github.com/nvim-treesitter/nvim-treesitter-textobjects)
  * `ip`  や `ap` のようにtextobjectを選択します。
  * 前後のtextobjectに移動します。
  * 関数の引数などの順番の前後を交換します。
  * textobject全体をfloating windowを使って表示します。
    Neovimの組み込みのLSPが必要です。
  * textobjectは設定で変えられます。
    [言語によって利用できるtextobjectは違います。](https://github.com/nvim-treesitter/nvim-treesitter-textobjects#built-in-textobjects)今後追加される可能性があります。

* [refactor](https://github.com/nvim-treesitter/nvim-treesitter-refactor)
  * カーソルの下にあるsymbolの定義位置に移動したり、定義されているsymbol一覧を表示します。
  * カーソルの下にあるsymbolをrenameします。
    同じスコープ内のsymbolが対象のため、違うスコープ内のsymbolはrenameされません。
  * カーソルの下にあるsymbolをhighlightします。
    同じスコープ内のsymbolが対象のため、違うスコープ内のsymbolはhighlightされません。
    Colorschemeの設定でhighlightされているか分かりづらいことがあります。
  * カーソルが存在するスコープ全体をhighlightします。
    Colorschemeの設定でhighlightされているか分かりづらいことがあります。

* [rainbow](https://github.com/p00f/nvim-ts-rainbow)
  [vim\-rainbow](https://github.com/frazrepo/vim-rainbow)のように括弧（e.g. `{([])}`)の色をネストごとに変更します。
* [nvim\-ts\-autotag](https://github.com/windwp/nvim-ts-autotag)
  HTMLタグの終了タグを自動的に挿入します。rename機能もあります。HTML専用のようです。

プラグイン

* [context](https://github.com/romgrk/nvim-treesitter-context)
  関数の引数部分や直近のif文の条件を常に表示させるようにします。リンク先のgifを見ればどんな機能かわかります。
  tree-sitterなしで同じ機能を[context\.vim](https://github.com/wellle/context.vim)でもできますが、[信頼性が低く、正しく表示できないこと](https://www.reddit.com/r/neovim/comments/jh7cbc/nvimtreesittercontext_lightweight_alternative_to/g9wfhwk/?utm_source=reddit&utm_medium=web2x&context=3)があるみたいです。 `context.vim` が `nvim-treesitter-context` の[機能を統合する予定はあるようです。](https://github.com/wellle/context.vim/issues/90)

* [sidekick\.nvim](https://github.com/ElPiloto/sidekick.nvim)
  関数や変数一覧を表示し、選択した定義に移動します。

[他にも拡張モジュールやプラグインはあります。](https://github.com/nvim-treesitter/nvim-treesitter/wiki/Extra-modules-and-plugins)

### Command

* `TSInstall {language}`
  `language` のparserをインストールします。 `TSInstall ` のときにtabを押せば対応している言語一覧が表示されます。 `all` の場合全てインストールします。
  `checkhealth` でインストールしたparserの状態を確認できます。
* `TSUninstall {language}`
  `language` のparserをuninstallします。
* `TSInstallInfo`
  対応している言語のparserをインストールしているか確認できます。
* `TSUpdate`
  インストールしているparser全てをupdateします。
* `TSConfigInfo`
  tree-sitterの設定情報を表示します。

### 設定方法

context以外の機能はモジュールにあたり、デフォルトで無効になっているため動きません。動かすには `TSEnableAll <機能名>` を使うか設定を変えます。contextはデフォルトで有効になっているため動きます。

:::details 設定例

```lua
require'nvim-treesitter.configs'.setup { -- 設定された言語のparserがインストールされていない場合、
  -- インストールします。
  ensure_installed = {'ruby', 'lua'},

  highlight = {
    -- `false` の場合、highlight機能を動かしません。
    enable = true,

    -- highlightの機能を無効にする、filetypeを指定します。
    disable = { "bash", "c" },
  },

  incremental_selection = {
    enable = true,

    keymaps = {
      -- 範囲選択を開始します。
      init_selection = "gnn",

      -- 1つ上のnodeに選択範囲を拡大します。
      node_incremental = "grn",

      -- 1つ上のスコープに選択範囲を拡大します。
      scope_incremental = "grc",

      -- 1つ下のnodeに選択範囲を縮小します。
      node_decremental = "grm",
    },
  },

  indent = {
    enable = true
  },

  textobjects = {
    -- `ip` や `ap` のようにtextobjectを選択します。
    select = {
      enable = true,
      keymaps = {
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["ac"] = "@class.outer",
        ["ic"] = "@class.inner",
      },
    },
    -- 前後のtextobjectに移動します。
    move = {
      enable = true,
      goto_next_start = {
        ["]m"] = "@function.outer",
        ["]]"] = "@class.outer",
      },
      goto_next_end = {
        ["]M"] = "@function.outer",
        ["]["] = "@class.outer",
      },
      goto_previous_start = {
        ["[m"] = "@function.outer",
        ["[["] = "@class.outer",
      },
      goto_previous_end = {
        ["[M"] = "@function.outer",
        ["[]"] = "@class.outer",
      },
    },

    -- 関数の引数の位置を交換します。
    swap = {
      enable = true,
      swap_next = {
        ["<leader>a"] = "@parameter.inner",
      },
      swap_previous = {
        ["<leader>A"] = "@parameter.inner",
      },
    },

    -- textobject全体をfloating windowを使って表示します。
    lsp_interop = {
      enable = true,
      peek_definition_code = {
        ["df"] = "@function.outer",
        ["dF"] = "@class.outer",
      },
    },
  },
  refactor = {
    -- カーソルの下にあるsymbolの定義位置に移動したり、
    -- 定義されているsymbol一覧を表示します。
    navigation = {
      enable = true,
      keymaps = {
        -- 定義に移動します。
        goto_definition = "gnd",

        -- 定義一覧を表示します。
        list_definitions = "gnD",

        -- 定義一覧を本の目次のようにネストがわかるように表示します。
        list_definitions_toc = "gO",

        -- カーソル下のsymbolの前後の利用位置に移動します。
        goto_next_usage = "<a-*>",
        goto_previous_usage = "<a-#>",
      },
    },

    -- カーソルの下にあるsymbolをrenameします。
    smart_rename = {
      enable = true,
      keymaps = {
        -- `grr` でrename処理が開始できます。
        smart_rename = "grr",
      },
    },
    -- カーソルの下にあるsymbolをhighlightします。
    highlight_definitions = { enable = true },

    -- カーソルが存在するスコープ全体をhighlightします。
    highlight_current_scope = { enable = true },
  },

  -- 括弧の色をネストごとに変更します。
  rainbow = {
    enable = true
  },
}
```

:::

### Colorschemes

nvim-treesitterから定義されたhighlight groupを利用しているcolorschemesがあります。
* [nvim-treesitterのWiki](https://github.com/nvim-treesitter/nvim-treesitter/wiki/Colorschemes)
  colorschemeのpreviewがあります。
* [awesome\-neovim](https://github.com/rockerBOO/awesome-neovim#treesitter-supported-colorschemes)
* [nvcode-color-schemes.vim](https://github.com/ChristianChiarulli/nvcode-color-schemes.vim)
  [開発している生放送のアーカイブ](https://www.youtube.com/watch?v=VDSuv-GaQ0s)

## [completion-nvim](https://github.com/nvim-lua/completion-nvim)

非同期の補完フレームワークです。組み込みのLSPに補完を提供するのが目的です。

### 機能

* 選択した補完のドキュメント情報を表示
* [Snippet plugin](https://github.com/nvim-lua/completion-nvim#enable-snippets-support)との連携
  `g:completion_enable_snippet` で設定できます。デフォルトの値は `v:null` です。
  新しいsnippet pluginの[deoppet.nvim](https://github.com/Shougo/deoppet.nvim)を開発している[Shougo](http://vinarian.blogspot.com)さんの[スニペットプラグインについて 2020 年版](https://zenn.dev/shougo/articles/snippet-plugins-2020)を読めば利用できるSnippetの特徴がわかります。
  * [snippets.nvim](https://github.com/norcalli/snippets.nvim)
  * [Neosnippet](https://github.com/Shougo/neosnippet.vim/)
  * [UltiSnips](https://github.com/SirVer/ultisnips)
  * [vim-vsnip](https://github.com/hrsh7th/vim-vsnip)
    [vim-vsnip-integ](https://github.com/hrsh7th/vim-vsnip-integ)があればLSPを利用したsnippetも利用できます。ただ、[neovimのbuilt-inのLSPのsnippetのデフォルト設定が無効に変更されたため、LSPの設定を変更する必要があるようです。](https://github.com/hrsh7th/vim-vsnip-integ/issues/32)また、vim-vsnip作成者の[hrsh7th](https://twitter.com/hrsh7th)さんも[自動補完プラグインのnvim\-compe](https://github.com/hrsh7th/nvim-compe)を開発しています。

* 補完のsourceを追加
  * [buffer](https://github.com/steelsojka/completion-buffers)
  * [treesitter](https://github.com/nvim-treesitter/completion-treesitter)
  * [tags](https://github.com/kristijanhusak/completion-tags)
  * [tabnine](https://github.com/aca/completion-tabnine)
  * [dadbod](https://github.com/kristijanhusak/vim-dadbod-completion)


### 設定方法

* 全てのバッファで機能を有効する場合
  `autocmd BufEnter * lua require'completion'.on_attach()`
* LSPが有効なバッファ場合のみ機能を有効する場合

```vim
" `vimls` の部分は使用するlnaguage serverに変更してください。
lua require'lspconfig'.vimls.setup{on_attach=require'completion'.on_attach}`
```

## [telescope.nvim](https://github.com/nvim-telescope/telescope.nvim)

Neovimのコントリビューターの[TJ](https://github.com/tjdevries)さんが作成している組み込みのLSPやtree-sitterとの連携ができるfuzzy finderです。
[fzf](https://github.com/junegunn/fzf)や[fzy](https://github.com/jhawthorn/fzy),[sk](https://github.com/lotabout/skim)との依存性はありません。fzfやfzyと連携したい場合は[拡張機能](https://github.com/nvim-telescope/telescope.nvim/wiki/Extensions)を利用してください。
プレビュー表示もあり、[bat](https://github.com/sharkdp/bat)があれば色付きで表示されます。
今回紹介する残りのfuzzy finderと違いtree-sitterと連携できます。

TJさんはこのtelescopeも含むプラグインやneovimの新機能の開発を[twitch](https://www.twitch.tv/teej_dv)で配信しています。[redditのneovimのコミュニティ](https://www.reddit.com/r/neovim/)で[スレッドをたてたり](https://www.reddit.com/r/neovim/comments/jmnow1/neovim_development_streams/)コメントもしています。telescopeの作成理由も[youtubueに投稿しています。](https://youtu.be/8SqFt5h2Lsg)

[fzf](https://github.com/junegunn/fzf.vim)や[fzf-preview](https://github.com/yuki-ycino/fzf-preview.vim),[denite](https://github.com/Shougo/denite.nvim),[ctrlp](https://github.com/ctrlpvim/ctrlp.vim)などとの違いは、Tips集の[Katapedia](https://github.com/yutakatay/katapedia)とプラグインの選択・管理のポイントを記載している[Vimプラグイン"の"カテゴリまとめ](https://qiita.com/yutakatay/items/f19b2a0a962a587db5cf)の作者の[yutakatay](https://yutakatay.github.io)さんの[Vimにたくさんあるファジーファインダー系プラグインを比較してみる](https://zenn.dev/yutakatay/articles/vim-fuzzy-finder)を参考にしてみてください。

### Picker

#### コマンドラインでの使い方

`Telescope <piker_name>` で実行できます。

* `Telescope builtin`
  オプションなし
* `Telescope git_files cwd=~/dotfiles`
  オプションを設定
* `Telescope find_files find_command=rg,--ignore,--hidden,--files`
  table型のオブションの場合は `,` で区切る

---

次のpicker達は全てtelescopeに組み込まれています。独自のpickerを追加したい場合は[READMEのCustomization](https://github.com/nvim-telescope/telescope.nvim#customization)や[WikiのConfiguration Recipes](https://github.com/nvim-telescope/telescope.nvim/wiki/Configuration-Recipes)が参考になります。

[組み込まれているpickerの紹介動画一覧](https://github.com/nvim-telescope/telescope.nvim/wiki/Showcase)

:::details 組み込まれているpicker一覧

##### ファイル名

* `find_files` (alias `fd`)
  検索に利用するコマンドの優先順位は `fd` => `fdfind` => `rg` => `find` です。
* `oldfiles`
* `file_browser`

##### Git

* `git_files`
* `git_status`
* `git_commits`
* `git_bcommits`
* `git_branches`

##### Grep

* `grep_string`
* `live_grep`

##### tags

* `tags`
* `current_buffer_tags`

##### バッファ

* `buffers`
* `marks`
* `current_buffer_fuzzy_find`
  現在のバッファの行がリストされ、選択した行に移動します。

##### quickfix & location

* `quickfix`
* `loclist`

##### コマンド

* `commands`
* `command_history`

##### autocommand

* `autocommands`

##### registers

* `registers`

##### ヘルプ

* `help_tags`
* `man_pages`

##### キーマップ

* `keymaps`

##### ファイルタイプ

* `filetypes`

##### オプション

* `vim_options`

##### colorscheme

* `colorscheme`

##### highlight

* `highlights`

##### spell

* `spell_suggest`
  オプション `spell` が有効である必要があります。

##### パッケージ

* `reloader`
  選択したパッケージモジュールを再読込します。

##### LSP

* `lsp_references`
* `lsp_definitions`
* `lsp_workspace_symbols`
* `lsp_document_symbols`
* `lsp_code_actions`
* `lsp_range_code_actions`
* `lsp_document_diagnostics`
* `lsp_workspace_diagnostics`

##### treesitter

* `treesitter`
  編集しているバッファ内の関数や変数一覧から選択したものに移動します。

##### Telescope

* `builtin`
  実行できるpickerをリストし、選択したものを実行します。
* `planets`
  惑星のドット絵が見れます。

:::

### Layout

リストやプレビューなどのレイアウトは設定できます。デフォルトのレイアウトだと、ディスプレイが縦だとプレビューが表示されません。[Dropdown](https://github.com/nvim-lua/telescope.nvim#dropdown)を使えば縦画面でもプレビューは表示されます。

デフォルトのレイアウトを変更するには次のようにします。値は[supported layouts](https://github.com/nvim-telescope/telescope.nvim/wiki/Layouts)が利用できます。

```lua
require'telescope'.setup{
  -- 画面幅に応じたレイアウトになるため、
  -- ディスプレイの向き関係なく、
  -- プレビューが表示されます。
  defaults = {layout_strategy = 'flex'}
}
```

### 拡張機能

* [DAP(Debug Adapter Protocol)](https://microsoft.github.io/debug-adapter-protocol/)
  * [vimspector](https://github.com/nvim-telescope/telescope-vimspector.nvim)
    PythonとVim scriptで書かれている[vimspector](https://github.com/puremourning/vimspector)を利用します。
  * [dap](https://github.com/nvim-telescope/telescope-dap.nvim)
    Luaで書かれている[nvim\-dap](https://github.com/mfussenegger/nvim-dap)を利用します。
* fuzzy finder
  * [fzf](https://github.com/nvim-telescope/telescope-fzf-writer.nvim)
  * [fzy](https://github.com/nvim-telescope/telescope-fzy-native.nvim)
* [frecency](https://github.com/nvim-telescope/telescope-frecency.nvim)
  Mozillaの[Frecencyアルゴリズム](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm)を利用して、最近使ったファイルの優先順位を高くします。
* [github](https://github.com/nvim-telescope/telescope-github.nvim)
  IssueやPull Request,gistを表示します。
* [ghq](https://github.com/nvim-telescope/telescope-ghq.nvim)
  `ghq list` の結果を表示します。

:::details もっと

* [z](https://github.com/delphinus/telescope-z.nvim)
  `z -l` を表示して、そのディレクトリに対してファイル検索(`Telescope fd`), `cd` や `lch` を行います。
* [Packer](https://github.com/nvim-telescope/telescope-packer.nvim)
  プラグイン管理のpackerで管理しているプラグイン一覧を表示します。
* [node-modules](https://github.com/delphinus/telescope-node-modules.nvim)
  `node_modules` directory内のpackagesを検索して、そのpackageのdirectoryに `cd` や `lcd` を行ないます。
* [media\-files](https://github.com/nvim-telescope/telescope-media-files.nvim)
  画像や動画、pdfなどのpreviewを見ます。
* [sonic-template](https://github.com/tamago324/telescope-sonictemplate.nvim)
  [sonictemplate](https://github.com/mattn/vim-sonictemplate)にあるtemplateを展開します。
* [memo](https://github.com/delphinus/telescope-memo.nvim)
  [mattn/memo](https://github.com/mattn/memo)に対して、listやgrepを行ないます。
* [cheat](https://github.com/nvim-telescope/telescope-cheat.nvim)
  [cheat.sh](https://github.com/chubin/cheat.sh)の結果をします。cheat.shのデータはSQLiteに保存するので[sql.nvim](https://github.com/tami5/sql.nvim)が必要です。
* [snippets](https://github.com/nvim-telescope/telescope-snippets.nvim)
  [snippets.nvim](https://github.com/norcalli/snippets.nvim)との統合です。
* [symbols](https://github.com/nvim-telescope/telescope-symbols.nvim)
  絵文字や顔文字一覧を表示します。
* [openbrowser](https://github.com/tamago324/telescope-openbrowser.nvim)
  設定したbookmark listから選択したURIをブラウザで開きます。

:::

## Package Manager

* [paq-nvim](https://github.com/savq/paq-nvim)
  シンプルなwrapperを目指している、小さい(約175行)なpackage managerです。Packerとは目指しているものが違うため、依存関係の設定や遅延読み込みはできません。

## Fuzzy Finder

* [nvim\-fzf](https://github.com/vijaymarupudi/nvim-fzf)
  fzfを利用します。fzf.vimより使いやすく、カスタマイズ性が高いと主張しています。ただ、`Files` や `History` などのpickerは標準で実装されていません。[Action API](https://github.com/vijaymarupudi/nvim-fzf#action-api)でneovimの関数を利用して、preview windowに表示する情報を変更できます。これを利用するためにfzf.vimを削除する必要はありません。
* [fuzzy.nvim](https://github.com/amirrezaask/fuzzy.nvim)
  telescopeから[多くのアイデアを取り入れて作成されました。](https://www.reddit.com/r/neovim/comments/jbmjpo/fuzzynvim_neovim_plugin/g8zft98/?utm_source=reddit&utm_medium=web2x&context=3)シンプルなAPIなので他のfuzzy finderのバックエンド追加は簡単です。組み込みのLSPを利用するコマンドも実装しています。
* [FZTerm](https://github.com/LoricAndre/fzterm.nvim)
  fzfを利用しています。こちらも組み込みのLSPにも対応しており、[git blameのコマンド](https://github.com/LoricAndre/fzterm.nvim#usage)を実装しています。[全てをカスタマイズできることを重視](https://www.reddit.com/r/neovim/comments/jmdb5u/fztermnvim_yet_another_floating_terminalfuzzy/)しているため、telescopeより[拡張するのは簡単みたいです。](https://github.com/LoricAndre/fzterm.nvim#extensions)
* [nvim\-fzy](https://github.com/mfussenegger/nvim-fzy)
  fzyに依存しています。

## Statusline

* [express\_line\.nvim](https://github.com/tjdevries/express_line.nvim)
  [Gitの情報を取得する関数](https://github.com/tjdevries/express_line.nvim#git-changes)が実装されています。組み込みのLSPの情報を取得する場合は[lsp-status.nvim](https://github.com/nvim-lua/lsp-status.nvim)を使えばいいようです。
* [galaxyline.nvim](https://github.com/glepnir/galaxyline.nvim)
  組み込みのLSPやcoc.nvimの[診断結果を表示する関数があります。](https://github.com/glepnir/galaxyline.nvim/blob/main/lua/galaxyline/provider_diagnostic.lua)
  [Gitの情報を取得する関数](https://github.com/glepnir/galaxyline.nvim#component-keyword)がありますが、ブランチ名取得以外は次のgit signを表示するプラグインが必要です。
  * [vim-gitgutter](https://github.com/airblade/vim-gitgutter)
  * [vim-sifnify](https://github.com/mhinz/vim-signify)
  * [gitsigns](https://github.com/lewis6991/gitsigns.nvim)
* [lualine.nvim](https://github.com/hoob3rt/lualine.nvim)
  速さと簡単な設定を売りにしています。lightlineやairlineより速く、0.1秒でプラグインを読み込みます。[テーマはいくつか内蔵されており](https://github.com/hoob3rt/lualine.nvim/blob/master/THEMES.md)、 `lualine.theme = 'onedark'` のように設定します。
  galaxylineと比較した際、使いやすさはlualine、カスタマイズ性の高さはgalaxylineが良いと作者が[redditでコメント](https://www.reddit.com/r/neovim/comments/kn5wo4/lualinenvim_a_blazing_fast_and_easy_to_configure/ghkfc4a/?utm_source=reddit&utm_medium=web2x&context=3)しています。
* [neoline\.vim](https://github.com/adelarsq/neoline.vim)
  [lightline.vim](https://github.com/itchyny/lightline.vim)にインスパイされて作られており、statusとtab両方とも変更できます。
* [nvim\-hardline](https://github.com/ojroques/nvim-hardline)
  [vim-airline](https://github.com/vim-airline/vim-airline)にインスパイアしており、簡単で軽いのを目標として作られています。statusとtab両方とも変更できます。
* [statusline.lua](https://github.com/beauwilliams/statusline.lua)
  設定は必要せず、他のプラグインと連携してgitの情報などを表示します。Tablineも変更できます。
  表示する情報と連携できるプラグイン
  * Git diff: [vim-signify](https://github.com/mhinz/vim-signify)
  * Git branch: [vim-fugitive](https://github.com/tpope/vim-fugitive)
  * Lint status: [ale](https://github.com/beauwilliams/statusline.lua/tree/master/plugin)
* [bubbly\.nvim](https://github.com/datwaft/bubbly.nvim)
  モードやファイル名をbubbleのような丸で表示します。

## Tabline

* [barbar.nvim](https://github.com/romgrk/barbar.nvim)
  * 全てのバッファをtablineに表示
  * tabの並び替え
  * ファイル名が同じバッファを開いた場合ディレクトリ名を追加して重複表示を防ぐ
* [nvim\-bufferline\.lua](https://github.com/akinsho/nvim-bufferline.lua)
  バッファ選択や並び替えもできます。barbar.nvimと違う点は、1つのウィンドウで複数のバッファを開いているときにそのバッファだけをタブラインに表示するMulti-window modeがあることです。

## 補完

* [nvim\-compe](https://github.com/hrsh7th/nvim-compe)
  vim-vsnip作成者の[hrsh7th](https://github.com/hrsh7th)さんが開発している補完プラグインです。組み込みのLSPやvim-vsnip、hrsh7thさんが開発しているLSPクライアントの[vim\-lamp](https://github.com/hrsh7th/vim-lamp)と連携できます。

## 括弧・テキストオブジェクト

* [nvim\-autopairs](https://github.com/windwp/nvim-autopairs)
  [lexima\.vim](https://github.com/cohama/lexima.vim)のように閉じ括弧などを自動入力します。
* [nvim\-ts\-autotag](https://github.com/windwp/nvim-ts-autotag)
  HTMLタグの終了タグを自動的に挿入します。rename機能もあります。HTML専用のようです。nvim-treesitterに依存しています。
* [surround.nvim](https://github.com/blackCauldron7/surround.nvim)
  [vim\-surround](https://github.com/tpope/vim-surround)のように括弧や引用符などで囲まれているテキストを編集できます。

## インクリメント・デグリメント

* [dial\.nvim](https://github.com/monaqa/dial.nvim)
  日付（日本語も含む）やアルファベット、Markdownのヘッダー(`#`)をインクリメント・デクリメントできます。[独自のインクリメント・デクメントも定義できます。](https://github.com/monaqa/dial.nvim#user-extension)
* [nrpattern\.nvim](https://github.com/zegervdv/nrpattern.nvim)
  標準のインクリメント・デクリメントを拡張します。dial.nvimとは違い、日付やアルファベットは自分で拡張しないとできません。独自のインクリメント・デクメントの定義はdial.nvimより[設定項目が多いです。](https://github.com/zegervdv/nrpattern.nvim)

## デバック

* [nvim\-dap](https://github.com/mfussenegger/nvim-dap)
  [vimspector](https://github.com/puremourning/vimspector)のように[DAP(Debug Adapter Protocol)](https://microsoft.github.io/debug-adapter-protocol/)クライントをneovimに実装します。[nvim\-dap\-virtual\-text](https://github.com/theHamsta/nvim-dap-virtual-text)を使えば結果をvirtual textとして表示できます。また、[telescopeと連携する拡張機能](https://github.com/nvim-telescope/telescope-dap.nvim)があります。

## Linter/Formater

* [format.nvim](https://github.com/lukas-reineke/format.nvim)
  編集中のバッファをに対してformatを非同期で実行します。Luaで書かれている同じformatterプラグインの[formatter\.nvim](https://github.com/mhartington/formatter.nvim)のPRとして最初書いてましたが、[アプローチを変えるため全て書き直して作成されました。](https://www.reddit.com/r/neovim/comments/jj0jj6/formatnvim_lua_formatter/)

## REPL

* [iron.nvim](https://github.com/hkupty/iron.nvim)
  NeovimからREPLを実行できるようにします。

## Quickfix

* [nvim\-bqf](https://github.com/kevinhwang91/nvim-bqf)
  quickfixを拡張します。
* [popfix](https://github.com/RishabhRD/popfix)
  拡張性の高いquickfixとfloating windowのAPIを提供します。

## インデント

* [indent\-guides\.nvim](https://github.com/glepnir/indent-guides.nvim)
  [vim\-indent\-guides](https://github.com/nathanaelkane/vim-indent-guides)のようにindentに色をつけて表示します。VSCodeの[indent\-rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow)のような機能を[実装予定](https://github.com/glepnir/indent-guides.nvim/commit/e35b221569b95cea5b29ebe3492ed985ac82d527)です。

## 検索

* [nvim\-hlslens](https://github.com/kevinhwang91/nvim-hlslens)
  検索にヒットした行の右にvirtual textで何件目か表示します。virtual textの内容やhighlightは変更できます。

## Git

* [gitsigns.nvim](https://github.com/lewis6991/gitsigns.nvim)
  [vim-gitgutter](https://github.com/airblade/vim-gitgutter)のように、diffの結果を記号で行の左端に表示します。
* [git\-blame\.nvim](https://github.com/f-person/git-blame.nvim)
  git blameをvirtual textとして表示します。
* [neogit](https://github.com/TimUntersberger/neogit)
  Emacsからgitリポジトリ操作ができる[Magit](https://magit.vc/)のNeovim版です。Vimの概念に合わせていくつか変更する予定があります。

## GitHub

* [octo\.nvim](https://github.com/pwntester/octo.nvim)
  IssueとPRをNeovimから操作できます。 `ListIssues <repo>` でtelescopeと連携できます。
* [codeql\.nvim](https://github.com/pwntester/codeql.nvim)
  コードの脆弱性を発見する[CodeQL](https://securitylab.github.com/tools/codeql)を実行できます。

## コメント

* [prodoc.nvim](https://github.com/glepnir/prodoc.nvim)
  コメント化・アノテーション追加します。
* [kommentary](https://github.com/b3nj5m1n/kommentary)
  コメントの切り替えを行います。

## エクスプローラー

* [nvim-tree.lua](https://github.com/kyazdani42/nvim-tree.lua)
  ツリー形式で表示します。ファイルの追加や削除、名前変更ができ、gitとの連携もできます。
* [lir\.nvim](https://github.com/tamago324/lir.nvim)
  シンプルなエクスプロラーで、ディレクトリ表示時(e.g. `e .`)に `Netrw` の代わりに利用できます。
* [dirbuf\.nvim](https://github.com/elihunter173/dirbuf.nvim)
  nvim-treeや[vim\-dirvish](https://github.com/justinmk/vim-dirvish),[vidir](https://github.com/trapd00r/vidir)にインスパイアされています。
* [neofs](https://github.com/TimUntersberger/neofs)
  floating windowで表示します。

## Colors

* [nvim\-colorizer\.lua](https://github.com/norcalli/nvim-colorizer.lua)
  カラーコードのプレビューができ、外部依存関係はありません。
  同じ機能を持つ[vim-hexokinase](https://github.com/RRethy/vim-hexokinase)はGo言語が必要です。
* [lush\.nvim](https://github.com/rktjmp/lush.nvim)
  colorscheme作成を支援します。色の変更をリアルタイムで反映します。

## プロジェクト管理

* [nvim\-projectconfig](https://github.com/windwp/nvim-projectconfig)
  `~/.config/nvim/projects/{プロジェクト名}` (変更可能）にある、プロジェクト専用の設定ファイル（Vimscript or lua)を読み込みます。
  `lua require('nvim-projectconfig').load_project_config()` で設定ファイルの読み込み、`lua.require("nvim-projectconfig").edit_project_config()` で設定ファイルを開きます。

## ヘルプ

* [nvim\-cheat\.sh](https://github.com/RishabhRD/nvim-cheat.sh)
  [cheat.sh](https://github.com/chubin/cheat.sh)を利用して、色んなコマンドを表示します。

## 共同編集

* [instant.nvim](https://github.com/jbyuki/instant.nvim)
  複数人で同じバッファを共有するライブ編集ができます。

## コピー/ペースト

* [nvim\-miniyank](https://github.com/bfredl/nvim-miniyank)
  [kill\-ring](http://ergoemacs.org/emacs/emacs_copy_cut_kill-ring.html)のように、yankの履歴を使えるようにします。

## ターミナル

* [nvim-toggleterm.lua](https://github.com/akinsho/nvim-toggleterm.lua)
  [neoterm](https://github.com/kassio/neoterm)のように複数のターミナルウィンドウを簡単に管理できます。
* [FTerm\.nvim](https://github.com/numtostr/FTerm.nvim)
  ターミナルをfloating windowで表示します。

## アイコン

* [nvim\-web\-devicons](https://github.com/kyazdani42/nvim-web-devicons)
  ファイルタイプのアイコンを追加する[vim\-devicons](https://github.com/ryanoasis/vim-devicons)のlua番
* [nvim\-nonicons](https://github.com/yamatsum/nvim-nonicons)
  [Nonicons](https://github.com/yamatsum/nonicons)を利用したアイコンセットです。[deviconとcodiconはcui用に設計されていないため、ターミナルだと見難いアイコンがあるため使用していないそうです。また、deviconはフォント間の統一性がなく、codiconにはファイルタイプのアイコンがないそうです。](https://www.reddit.com/r/neovim/comments/m5eu4w/icon_set_using_nonicons_for_neovim_plugins_and/)
* [codicons\.nvim](https://github.com/mortepau/codicons.nvim)
  VSCodeの[codicon](https://microsoft.github.io/vscode-codicons/dist/codicon.html)を簡単に利用できるようになります。

## スクロールバー

* [scrollbar\.nvim](https://github.com/Xuyuanp/scrollbar.nvim)
  スクロールバーの見た目を変更します。

## ウィンドウ

* [wintablib.nvim](https://github.com/notomo/wintablib.nvim)
  ウィンドウやタブを操作する関数を提供します。
  * 左 or 右の全てのタブを閉じる
  * 左 or 右のタブのバッファを、現在のタブで開く
  * 編集中のバッファを新規タブで開く
    タブは左右どちらに配置するか決めることができます。
  * 全てのfloating windowを閉じる
  * 上下左右のwindowを全て閉じる

## マウス

* [gesture.nvim](https://zenn.dev/notomo/articles/neovim-mouse-gesture-plugin)
  マウスジェスチャーができるようになります。

## コマンドライン

* [cmdbuf.nvim](https://github.com/notomo/cmdbuf.nvim)
  `q` => `:` で開けるコマンドラインウィンドウをバッファとして開きます。

## モーション

* [hop\.nvim](https://github.com/phaazon/hop.nvim)
  [vim-easymotion](https://github.com/easymotion/vim-easymotion)のLua版で、1から書き直しています。
* [train.nvim](https://github.com/tjdevries/train.nvim)
  モーションを拡張します。

## セッション

* [auto-session](https://github.com/rmagatti/auto-session)
  自動でセッションを保存、読み込みを行ないます。

## Markdown

* [glow\.nvim](https://github.com/npxbr/glow.nvim)
  Floating windowに[glow](https://github.com/charmbracelet/glow)でレンダーしたMarkdownを表示します。glowを使うのでGo言語が必要です。同じ機能を提供する[preview\-markdown\.vim](https://github.com/skanehira/preview-markdown.vim)とは次が違います。
  * Floating windowで表示
  * 対応レンダーはglowのみ
    preview-markdownは[mdr](https://github.com/MichaelMure/mdr)と[mdcat](https://github.com/lunaryorn/mdcat)にも対応しています。ただ、 glow.nvimの `open_window` 内の [`api.nvim_call_function("termopen", {string.format("glow %s", path)})`](https://github.com/npxbr/glow.nvim/blob/21ed617b1a16997a02f54ae05c1a9dc3f3c503bf/lua/glow.lua#L99) の `glow` を `mdcat` にコードを変更すれば `mdcat` でも動きます。
  * 自動更新機能なし
   [preview-markdownは自動更新できますがVimのみでNeovimは対応していません。](https://github.com/skanehira/preview-markdown.vim#options)

## 設定

* [fey\_neovim](https://github.com/faerryn/fey_neovim)
  [Doom Emacs](https://github.com/hlissner/doom-emacs)にインスパイアされた設定フレームワークで、[minpac](https://github.com/k-takata/minpac)をパッケージマネージャーに使っています。

:::message
Neovimユーザーが欲しいと思っているLua製のプラグインを記載する公開カタログが[nvim\-lua/wishlist](https://github.com/nvim-lua/wishlist)にあります。また、[awesome\-neovim](https://github.com/rockerBOO/awesome-neovim#treesitter-support)もあります。
:::

:::details 前まで表示してたもの

## 生活

* [weather\.nvim](https://github.com/npxbr/weather.nvim)
  [wttr\.in](https://github.com/chubin/wttr.in)を利用して、天気を表示します。

## Mode

* [nvim\-libmodal](https://github.com/Iron-E/nvim-libmodal)
  このプラグインと連携するプラグインをインストールすれば、[バッファ](https://github.com/Iron-E/nvim-bufmode)や[タブ](https://github.com/Iron-E/nvim-tabmode)管理する独自のモードを追加できます。

## エクスプローラー

* [nvim\-filetree](https://github.com/beardedsakimonkey/nvim-filetree)
  ツリー形式でファイルを表示します。

## 可視化

* [nvim\-visual\-eof\.lua](https://github.com/LumaKernel/nvim-visual-eof.lua)
  EOLを `⏎` などで可視化します。

## ゲーム

* [vim\-apm](https://github.com/ThePrimeagen/vim-apm)
  1分間のキー操作の回数を表示します。
* [vim\-be\-good](https://github.com/ThePrimeagen/vim-be-good)
  Vimの基本の動きを練習するゲームができます。

:::

# Luaのプラグイン作成に役立つプラグインやドキュメント

## プラグイン

* [nlua.nvim](https://github.com/tjdevries/nlua.nvim)
  Lua開発に役立つ機能を提供します。
* [nvim\-luadev](https://github.com/bfredl/nvim-luadev)
  Luaプラグイン用のREPLとdebug機能を提供します。
* [nvim-luapad](https://github.com/rafcamlet/nvim-luapad)
  入力しているLuaのコードをリアルタイムで実行します。
* [manillua.nvim](https://github.com/tjdevries/manillua.nvim)
  Luaの折りたたみ表示を見やすくします。
* [lreload.nvim](https://github.com/notomo/lreload.nvim)
  Luaモジュールのhot-reloadingができます。

### Library

* [plenary\.nvim](https://github.com/nvim-lua/plenary.nvim)
  Neovim専用のluaライブラリです。Luaモジュール用のpackage mangerの[LuaRocks](https://luarocks.org)を使って[lua packageをインストールできます。](https://github.com/nvim-lua/plenary.nvim#plenaryneorocks)
* [popup.nvim](https://github.com/nvim-lua/popup.nvim)
  Vimの[Popup API](https://vim-jp.org/vimdoc-ja/popup.html)と互換性があるAPIをNeovimに実装します。
* [vlog\.nvim](https://github.com/tjdevries/vlog.nvim)
  Luaプラグインに簡単にログファイルを実装できます。依存性はありません。
* [neovim\-plugin](https://github.com/norcalli/neovim-plugin)
  プラグインのキーマップやコマンド、イベント設定をLuaのtable形式で設定できます。
* [impromptu\.nvim](https://github.com/hkupty/impromptu.nvim)
  コマンドや関数を呼び出すためのプロンプトを簡単に作成できます。
* [sql\.nvim](https://github.com/tami5/sql.nvim)
  neovimからSQLiteを操作するwrapperです。

## ドキュメント

* [nvim-lua-guide](https://github.com/nanotee/nvim-lua-guide#existing-tutorials-for-writing-lua-in-neovim)
* [jacobsimpson/nvim\-example\-lua\-plugin](https://github.com/jacobsimpson/nvim-example-lua-plugin)
* [How to write neovim plugins in Lua \| 2n it sp\. z o\.o\.](https://www.2n.pl/blog/how-to-write-neovim-plugins-in-lua)
* [Lua製Neovim pluginのテストをLuaで書く](https://zenn.dev/notomo/articles/neovim-lua-plugin-testing)
* [Lua製Neovim plugin開発でhot\-reloading的な体験を得る](https://zenn.dev/notomo/articles/neovim-lua-plugin-hot-reload)
* [Neovim Async Tutorial](https://ms-jpq.github.io/neovim-async-tutorial/)
* [anthony\-khong/nvim\-education](https://github.com/anthony-khong/nvim-education)

# 参考資料

本文内でリンクを記載していない資料達です。

## NeovimとLuaが相性が良い理由

* [Developing plugins for Neovim, is there a guide or how\-to? : neovim](https://www.reddit.com/r/neovim/comments/6ami38/developing_plugins_for_neovim_is_there_a_guide_or/)
* [Neovim Development Streams\! : neovim](https://www.reddit.com/r/neovim/comments/jmnow1/neovim_development_streams/gaw9scy/)

## Native Packages

* [Vim 8\.0 Advent Calendar 6 日目 パッケージ \- Qiita](https://qiita.com/thinca/items/cdc0169e3bcc5a55a5ba)
* [Vim 8 時代のがんばらないプラグイン管理のすすめ \- Humanity](https://tyru.hatenablog.com/entry/2017/12/20/035142)
* [Vimのパッケージ機能を試してみました \- Blank File](http://h-miyako.hatenablog.com/entry/2016/02/29/211534)
* [Vim 8\.0用のプラグインマネージャを作ってみた話 \- Qiita](https://qiita.com/k-takata/items/36c240a23f88d699ce86)

## nvim-lspconfig

* [Vimconf.live: Neovim Builtin LSP](https://www.youtube.com/watch?v=C9X5VF9ASac)
* [Neovim LSPSetup | Part 1](https://www.youtube.com/watch?v=CCUFml9yB64)
* [Getting started with Nvim + LSP \(Quick Start\)](https://www.youtube.com/watch?v=tOjVHXaUrzo)

## nvim-treesitter

* [What is Neovim tree sitter : neovim](https://www.reddit.com/r/neovim/comments/jr7gbz/what_is_neovim_tree_sitter/)

## Tree-sitter

* [Atom understands your code better than ever before \- The GitHub Blog](https://github.blog/2018-10-31-atoms-new-parsing-system/)
* [新しいマークダウンパーサーが必要な理由](https://meetup-jp.toast.com/3341#Tree-Sitter)
* [「Atom 1\.32」が正式公開 ～構文解析システム「tree\-sitter」をついにデフォルト有効化 \- 窓の杜](https://forest.watch.impress.co.jp/docs/news/1149887.html)
